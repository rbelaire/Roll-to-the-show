# Roll to the Show — Architecture (v1)  ## Guiding Principles - Engine is deterministic and UI-agnostic - All randomness is injected via a seedable RNG interface - Game rules live in pure functions operating on serializable state - Dice outcomes are data-driven (tables) and modified by data-driven modifiers - UI is a thin client that renders state and dispatches actions - Persistence stores state snapshots only (no derived state required to restore)  ---  ## Repository Structure - `src/game/` — pure gameplay engine (no React, no DOM, no timers)   - `src/game/types/` — core state and config types (serializable)   - `src/game/engine/` — game reducer/state machine and rule application   - `src/game/dice/` — dice tables and resolution logic   - `src/game/modifiers/` — modifier application, stacking, expiration   - `src/game/events/` — event definitions and event resolution   - `src/game/modes/` — mode orchestration (Season vs Run), no math - `src/ui/` — React UI, animations, presentation, input handling - `docs/` — PRD, architecture, and design decisions  ---  ## High-Level System Overview  ### Core loop UI displays current state → player taps Roll → UI dispatches an action → engine resolves dice outcome using injected RNG + active modifiers → engine applies outcome to state → UI re-renders.  ### Non-negotiable separation - The engine does not import from `src/ui/` - The UI never implements game math (only calls engine and renders results)  ---  ## Data Model (Conceptual) The engine operates on a single serializable root object:  - `AppState`   - `mode`: `standardSeason | runToTheShow`   - `game`: `GameState` (current in-progress or last completed game)   - `season?`: `SeasonState` (only in standard season)   - `run?`: `RunState` (only in rogue-like mode)   - `meta`: `MetaState` (unlock currency, unlocks)   - `settings`: `SettingsState` (defaults like innings; v1 mostly fixed)  All state must be JSON-serializable.  ---  ## RNG (Determinism Contract)  ### Requirements - The engine never calls `Math.random()` - RNG is injected as a function (or object) passed into engine calls - Given the same initial state + same RNG seed, outcomes are identical  ### Recommended interface - `rng.nextFloat(): number` returning [0, 1)  UI creates RNG seeded per game/run and passes it to engine entry points.  ---  ## Engine API Surface  ### Pure reducer model (recommended) The engine exposes functions like:  - `startNewGame(modeContext) -> GameState` - `roll(state: GameState, context, rng) -> { state: GameState, effects }` - `applyOutcome(state: GameState, outcome) -> GameState`  Where `effects` are UI hints (commentary strings, highlight type), not logic.  ### Why this design - Easy to test - Easy to simulate thousands of games headlessly - UI stays dumb  ---  ## Dice Resolution System  ### Inputs - Base dice table (probability distribution over outcomes) - Active modifiers list - Context (inning, outs, runners, score, tier, etc.) - RNG  ### Output - A single resolved `DiceOutcome`  ### Probability policy - Modifiers transform weights or probabilities - Final distribution is normalized to sum to 1 - If distribution is invalid (all weights 0 or NaN), engine throws an error in dev/test  ### Tables are configuration Dice tables are plain data objects stored in `src/game/dice/`. No hardcoded magic numbers in the resolver.  ---  ## Modifier System  ### Modifier types A modifier can: - Multiply weight for a named outcome (e.g., HR * 1.2) - Add weight for a named outcome (e.g., Walk + 0.05 weight) - Clamp an outcome weight between min/max (optional; avoid unless needed)  ### Stacking rule (v1 decision) - Apply all multiplicative effects first (in any order) - Apply all additive effects second - Normalize distribution after all effects  This is deterministic, easy to explain, and predictable.  ### Scope A modifier can target: - `game` (only current game) - `tier` (current tier in rogue-like) - `run` (entire run)  ### Duration / Expiration Each modifier has exactly one expiration rule: - `rollsRemaining` (decrement every roll) OR - `gamesRemaining` (decrement at game end) OR - `tierEnd` (expires when tier completes) OR - `runEnd` (expires when run ends)  The engine is responsible for decrementing and removing expired modifiers.  ### Visibility All active modifiers must be enumerable from state for UI display.  ---  ## Game Rules Engine (Applying Outcomes)  ### Outcome application Each outcome has a deterministic state transition: - updates outs - updates base runners - updates runs scored - may end the half-inning (e.g., third out, double play) - may switch sides and advance inning  ### Half-inning and inning transitions - 3 outs ends the half-inning - After top half ends → bottom half begins - After bottom half ends → next inning begins  ### End-of-game rule (v1 decision) - No extra innings - If tied after final inning: player loses (Defined in PRD; engine enforces consistently.)  ---  ## Mode Orchestration  ### Standard Season - Season is a container that starts games and records final results - Season state updates only at game end:   - W/L   - runs scored/allowed totals - No events, no rogue modifiers  ### Run to the Show - Run is a tiered state machine:   - tiers: Single-A → Double-A → Triple-A → The Show   - each tier is N games with a win requirement - Events occur between some games:   - event yields exactly 2 choices   - choice applies modifiers (game/tier/run) - Run ends immediately when tier requirement can no longer be met or tier completes and promotion fails.  ---  ## Events System  ### Data-driven definitions Events are configuration entries: - id, title, description - two choices:   - choice text   - effects list (add/remove modifiers, adjust meta reward multipliers if desired)  No event should contain custom code; only data.  ### Resolution Engine applies chosen effects to the run state. UI is responsible for presenting the text and capturing the choice.  ---  ## Persistence  ### What to persist Persist the entire `AppState` snapshot: - season state (if present) - run state (if present) — v1 rule: no saving mid-run, so this may be absent or only meta - meta state - last completed game summary (optional)  ### Where - Local storage (web) or device storage (RN) using a single JSON blob - Include a schema version for future migrations  ### What NOT to persist - Derived UI-only state - Animation state - Anything non-serializable  ---  ## Testing Strategy (Phase 1+ dependency) - Unit tests for:   - dice resolution normalization and determinism   - modifier stacking and expiration   - outcome application (base runner + outs correctness) - Simulation tests:   - run 1,000+ games headlessly to validate distribution sanity  ---  ## Explicit Non-Goals (v1) - Multiplayer - Cloud saves - Branching path map UI - Deep roster/GM systems - Complex AI (beyond fixed tables/modifiers)

